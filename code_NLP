{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d83a98e8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Zhaoyang Xu, August 2021, code for technology policy\n",
    "\n",
    "\n",
    "# Import necessary libraries\n",
    "import codecs\n",
    "import joblib\n",
    "import matplotlib\n",
    "import matplotlib as mpl\n",
    "import matplotlib.pyplot as plt\n",
    "import mpld3\n",
    "import nltk\n",
    "import numpy as np\n",
    "import os\n",
    "import pandas as pd\n",
    "import plotly.graph_objects as go\n",
    "import re\n",
    "from __future__ import print_function\n",
    "from sklearn import feature_extraction\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.manifold import MDS\n",
    "from sklearn.metrics.pairwise import cosine_similarity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "697c41b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load the dataset\n",
    "df0 = pd.read_csv(\"policy1.csv\")\n",
    "df0.head()\n",
    "\n",
    "# Define vectorizer parameters\n",
    "tfidf_vectorizer = TfidfVectorizer(max_df=0.8, min_df=0.2)\n",
    "\n",
    "# Fit the vectorizer to the 'clean' column of the dataframe and transform the data into a tf-idf matrix\n",
    "tfidf_matrix = tfidf_vectorizer.fit_transform(df0[\"clean\"])\n",
    "\n",
    "# Extract the feature names (terms) from the tf-idf vectorizer\n",
    "terms = tfidf_vectorizer.get_feature_names_out()\n",
    "\n",
    "# Compute the pairwise cosine similarity distances and convert to a distance measure\n",
    "dist = 1 - cosine_similarity(tfidf_matrix)\n",
    "\n",
    "# Save the distance matrix to a CSV file\n",
    "pd.DataFrame(dist).to_csv(\"distance_pairwise.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "09346d79",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the number of clusters for KMeans\n",
    "num_clusters = 5\n",
    "\n",
    "# Initialize and fit the KMeans clustering model on the tf-idf matrix\n",
    "km = KMeans(n_clusters=num_clusters)\n",
    "km.fit(tfidf_matrix)\n",
    "\n",
    "# Get the cluster labels for each document\n",
    "clusters = km.labels_.tolist()\n",
    "\n",
    "# Load a previously saved KMeans model\n",
    "km = joblib.load('doc_cluster.pkl')\n",
    "\n",
    "# Assign the cluster labels to the dataframe\n",
    "df0[\"cluster\"] = clusters\n",
    "\n",
    "# Count the number of documents in each cluster\n",
    "df0['cluster'].value_counts()\n",
    "\n",
    "# Group the dataframe by cluster for aggregation purposes\n",
    "grouped = df0['Complexity'].groupby(df0['cluster'])\n",
    "\n",
    "# Calculate the mean complexity rank (1 to 100) per cluster\n",
    "grouped.mean()\n",
    "\n",
    "# Initialize MDS (Multidimensional Scaling)\n",
    "MDS()\n",
    "\n",
    "# Initialize MDS (Multidimensional Scaling) with 2 components\n",
    "# The 'dissimilarity' parameter is set to 'precomputed' because we are using a precomputed distance matrix\n",
    "# The 'random_state' parameter is set for reproducibility\n",
    "mds = MDS(n_components=2, dissimilarity=\"precomputed\", random_state=1)\n",
    "\n",
    "# Fit the MDS model to the distance matrix and transform the data\n",
    "# The resulting 'pos' array contains the 2D coordinates for each point (document)\n",
    "pos = mds.fit_transform(dist)  # shape (n_samples, n_components)\n",
    "\n",
    "# Extract the x and y coordinates from the transformed data\n",
    "xs, ys = pos[:, 0], pos[:, 1]\n",
    "\n",
    "# Print a message indicating that the top terms per cluster will be displayed\n",
    "print(\"Top terms per cluster:\")\n",
    "print()\n",
    "\n",
    "# Sort cluster centers by proximity to centroid\n",
    "order_centroids = km.cluster_centers_.argsort()[:, ::-1]\n",
    "for i in range(num_clusters):\n",
    "    print(\"Cluster %d words:\" % i, end='')\n",
    "\n",
    "    # Print top n words per cluster\n",
    "    for ind in order_centroids[i, :6]:  # replace 6 with desired number of words\n",
    "        print(' %s' % terms[ind].split(' '))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb5b2301",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define cluster colors\n",
    "cluster_colors = {0: '#1b9e77', 1: '#d95f02', 2: '#7570b3', 3: '#e7298a', 4: '#66a61e'}\n",
    "\n",
    "# Set font for matplotlib\n",
    "myfont = r'/System/LibraryFonts/Supplemental/Songti.ttc'\n",
    "matplotlib.rcParams['font.family'] = ['Heiti TC']\n",
    "\n",
    "# Define cluster names\n",
    "cluster_names2 = {\n",
    "    0: 'Enterprise, Recognize, High-tech enterprises, Service, Ten thousand yuan, Method', \n",
    "    1: 'Unit, Method, Country, Reward, Innovation, Review', \n",
    "    2: 'Innovation, Enterprise, Construction, Support, Service, Industry', \n",
    "    3: 'Project, Unit, Funds, Acceptance, Undertake, Plan', \n",
    "    4: 'Patent, Intellectual property, Enterprise, Funding, Protection, Unit'\n",
    "}\n",
    "\n",
    "# Create 'cityyear' column\n",
    "df0[\"cityyear\"] = df0.apply(lambda x: x[\"City\"] + str(x[\"Year\"]), axis=1)\n",
    "\n",
    "# Display matplotlib plots inline\n",
    "%matplotlib inline\n",
    "\n",
    "# Create DataFrame with MDS results and cluster info\n",
    "df = pd.DataFrame(dict(x=xs, y=ys, label=clusters, title=df0[\"cityyear\"]))\n",
    "\n",
    "# Group by cluster\n",
    "groups = df.groupby('label')\n",
    "\n",
    "# Create Plotly figure\n",
    "fig = go.Figure()\n",
    "\n",
    "# Add scatter plot traces for each cluster\n",
    "for name, group in groups:\n",
    "    fig.add_trace(go.Scatter(\n",
    "        x=group.x, y=group.y,\n",
    "        legendgroup=cluster_names2[name], name=cluster_names2[name],\n",
    "        mode=\"markers\", marker=dict(color=cluster_colors[name], size=10),\n",
    "        text=group.title\n",
    "    ))\n",
    "\n",
    "# Update plot layout\n",
    "fig.update_layout(\n",
    "    autosize=False, width=1500, height=800,\n",
    "    title='Clustering, Grouped by Topics'\n",
    ")\n",
    "\n",
    "# Show plot\n",
    "fig.show()\n",
    "\n",
    "# Save plot as HTML\n",
    "fig.write_html(\"clustering_grouped_by_topic.html\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
